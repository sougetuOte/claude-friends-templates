# AI-Friendly Comments ガイドライン

## 概要
AI駆動開発において、適切なコメントはAIの理解精度を大幅に向上させます。
このガイドラインは、人間とAIの両方にとって価値のあるコメントの書き方を定義します。

## 基本方針

### 推奨するコメント ✅
1. **なぜ（Why）の説明**
   - その実装を選んだ理由
   - ビジネスロジックの背景
   - 設計上の決定事項

2. **意図と制約の明確化**
   - 将来のAI/開発者への意図の伝達
   - パフォーマンスやセキュリティ上の考慮事項
   - 一見不自然に見える実装の正当性

3. **ビジネスルールの文書化**
   ```javascript
   /**
    * ユーザーの購入履歴から推奨商品を計算する
    *
    * ビジネスルール:
    * - 同じカテゴリの商品を3回以上購入したユーザーには関連商品を推奨
    * - 直近30日間の購入傾向を重視（重み付け: 0.7）
    * - 季節性を考慮（夏は冷感商品、冬は保温商品の重みを増やす）
    *
    * @param userId - 対象ユーザーのID
    * @param options - 推奨オプション（カテゴリ絞り込み、除外商品など）
    * @returns 推奨商品リスト（最大10件、スコア降順）
    */
   function calculateRecommendations(userId, options) {
     // 実装
   }
   ```

### 避けるべきコメント ❌
1. **自明な処理の説明**
   ```javascript
   // ❌ 悪い例
   i++; // iを1増やす

   // ❌ 悪い例
   const users = []; // ユーザーの配列
   ```

2. **コードの日本語訳**
   ```javascript
   // ❌ 悪い例
   if (user.age > 18) { // ユーザーの年齢が18より大きい場合
   ```

3. **更新されないリスクが高い詳細仕様**
   ```javascript
   // ❌ 悪い例
   // このメソッドは5つのステップで処理を行う
   // 1. データベースから取得
   // 2. 変換処理... (以下、実装と乖離しやすい)
   ```

## AI向けコメントのパターン

### 1. 複雑なアルゴリズムの説明
```python
def optimize_route(locations):
    """
    配送ルートを最適化する

    アルゴリズム: 改良版最近傍法
    - 開始点から最も近い未訪問地点を選択
    - ただし、時間制約がある地点を優先
    - 全体の移動距離が閾値を超えたら分割を検討

    計算量: O(n²)
    メモリ: O(n)

    注意: locations が100を超える場合は
    分割統治法への切り替えを推奨
    """
    # 実装
```

### 2. エラーハンドリングの意図
```typescript
try {
  await processPayment(order);
} catch (error) {
  // 決済エラーは3種類に分類して処理
  // 1. 一時的エラー: リトライ可能（ネットワーク等）
  // 2. 永続的エラー: リトライ不可（残高不足等）
  // 3. システムエラー: エスカレーション必要

  if (isTemporaryError(error)) {
    // 最大3回までリトライ、指数バックオフ使用
    return retryWithBackoff(processPayment, order);
  }
  // 以下、エラー種別ごとの処理
}
```

### 3. パフォーマンス最適化の記録
```go
// キャッシュ戦略: LRU with TTL
// - 容量: 1000エントリ
// - TTL: 5分（アクセス頻度の分析結果に基づく）
// - ヒット率目標: 80%以上
//
// 注意: DBクエリ削減のため、若干の遅延は許容
cache := NewLRUCache(1000, 5*time.Minute)
```

### 4. セキュリティ考慮事項
```ruby
# セキュリティ: SQLインジェクション対策
# - すべての入力をパラメータ化クエリで処理
# - ホワイトリスト方式でカラム名を検証
# - 実行前にクエリログを記録（監査用）
def search_users(criteria)
  allowed_columns = %w[name email created_at]
  # バリデーションと実装
end
```

## 言語別の推奨フォーマット

### JavaScript/TypeScript
```javascript
/**
 * JSDocスタイルを使用
 * @param {string} param - パラメータの説明
 * @returns {Object} 戻り値の説明
 * @throws {Error} エラー条件
 */
```

### Python
```python
"""
Googleスタイルのdocstring使用

Args:
    param (str): パラメータの説明

Returns:
    dict: 戻り値の説明

Raises:
    ValueError: エラー条件
"""
```

### Go
```go
// Package レベルのコメント
// このパッケージは...を提供します

// Function レベルのコメント
// FunctionName は...を行います
// 特記事項があれば記載
```

## コメント更新のルール

### 必須更新タイミング
1. **機能変更時**: ビジネスロジックの変更
2. **バグ修正時**: 修正の理由と対策を追記
3. **パフォーマンス改善時**: 変更前後の比較

### 更新時のテンプレート
```javascript
/**
 * [元のコメント]
 *
 * 更新履歴:
 * - 2024-01-15: 季節性の重み付けロジックを追加（夏冬対応）
 * - 2024-03-20: パフォーマンス改善（クエリ数を50%削減）
 */
```

## チーム運用のベストプラクティス

### コードレビュー時のチェック項目
- [ ] 複雑な処理にコメントがあるか
- [ ] コメントと実装が一致しているか
- [ ] ビジネスロジックが説明されているか
- [ ] 将来の保守者への配慮があるか

### AIツール利用時の注意
- コメントがAIの理解を助けているか確認
- 過度に詳細なコメントは避ける
- 意図と背景に焦点を当てる

## まとめ
良いコメントは、コードの「What」ではなく「Why」を説明します。
AI時代においては、この原則がさらに重要になります。
適切なコメントにより、AIは実装の意図を正確に理解し、
より良い提案や修正を行うことができます。

---
*「コードは How を語り、コメントは Why を語る」*
